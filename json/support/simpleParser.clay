import test.*;
import maybe.*;

import json.support.tokenStream.*;
import json.support.misc.*;



/// simple parser


record SimpleParserState[S] (
    input: S,
    inputLength: SizeT,
    pos: SizeT,
);

[S]
overload TokenStream?(static SimpleParserState[S]) = true;

[S]
overload lookahead?(state: SimpleParserState[S]) {
    if (state.pos == state.inputLength)
        return nothing(Char);
    return Maybe(state.input[state.pos]);
}

[S]
overload advance(stream: SimpleParserState[S]) {
    checkNotEof(stream);
    stream.pos += 1;
}

simpleParser(input) =
    SimpleParserState(input, size(input), SizeT(0));


private pushState(parser) {
    return parser.pos;
}

private popState(parser, savedState) {
    parser.pos = savedState;
}


alias lookingAtChar = lookingAtToken;
alias lookingAtChars = lookingAtTokens;
alias consumeIfLookingAtChar = consumeIfLookingAtToken;
alias consumeIfLookingAtCharTo = consumeIfLookingAtTokenTo;

lookingAtString(state, expected) {
    var parserState = pushState(state);
    finally popState(state, parserState);
    for (c in expected) {
        if (not lookingAtChar(state, c)) {
            return false;
        }
        consumeChar(state);
    }
    return true;
}

alias consumeChar = consumeToken;

consumeCharAsString(state) {
    return String(consumeChar(state));
}

consumeChars(stream, ..expecteds) {
    var s = String();
    consumeTokensTo(stream, s, ..expecteds);
    return s;
}

consumeString(state, expected) {
    if (not lookingAtString(state, expected))
        error("expecting something else");
    var r = substr(state.input, state.pos, size(expected));
    state.pos += size(expected);
    return r;
}

private isSpace(char) =
    char == ' ' or char == '\t' or char == '\n';

consumeSpaces(state) {
    // TODO: proper whitespace
    consumeWhile(state, isSpace);
}


